<!DOCTYPE html>
<html lang="en" class="h-full overflow-x-hidden">
<head>
    <meta charset="UTF-8">
    <!-- 
      IMPORTANT: This meta tag prevents zooming on mobile WebViews, 
      which is critical for an embedded app experience.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <title>Test Copy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the hidden file input */
        .hidden-file-input {
            opacity: 0;
            position: absolute;
            width: 1px;
            height: 1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
        }
        /* Custom scrollbar for chat messages */
        #chat-messages {
            scrollbar-width: thin;
            scrollbar-color: #4b5563 #111827;
        }
        #chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        #chat-messages::-webkit-scrollbar-track {
            background: #1f2937; /* Even darker gray for track */
        }
        #chat-messages::-webkit-scrollbar-thumb {
            background-color: #4b5563; /* Dark gray for thumb */
            border-radius: 20px;
        }
        /* Base message bubble style */
        .chat-bubble {
            padding: 10px 14px;
            border-radius: 18px;
            max-width: 80%; /* Relative width for mobile */
            word-wrap: break-word;
            line-height: 1.4;
        }
        /* Sender's message bubble */
        .bubble-sent {
            background-color: #dcf8c6; /* WhatsApp green */
            color: #303030; /* Dark text */
            border-bottom-right-radius: 4px;
        }
        /* Receiver's message bubble */
        .bubble-received {
            background-color: #ffffff; /* White */
            color: #303030; /* Dark text */
            border-bottom-left-radius: 4px;
        }
        /* Timestamp style */
        .timestamp {
            font-size: 0.75rem; /* 12px */
            color: #6b7280; /* Gray-500 */
            margin-top: 4px;
        }
        /* Image timestamp overlay */
        .image-timestamp {
            position: absolute;
            bottom: 6px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 0.75rem; /* 12px */
            padding: 2px 6px;
            border-radius: 10px;
            user-select: none;
        }
    </style>
</head>
<body class="h-dvh flex flex-col bg-white text-gray-900 w-full overflow-x-hidden">

    <!-- 
      Container for the entire app. 
      This will be either the login screen or the chat screen.
    -->
    <div id="app-container" class="h-full w-full">
        
        <!-- Login Screen -->
        <div id="login-screen" class="h-full w-full flex flex-col items-center p-4">
            <div class="w-full max-w-sm mx-auto mt-[20vh]">
                <h1 id="login-title" class="text-3xl font-bold text-center mb-8 text-gray-900">Enter Your PIN</h1>
                <div id="pin-inputs" class="flex justify-center space-x-2 mb-6">
                    <!-- PIN inputs will be generated by JS -->
                </div>
                <p id="login-error" class="text-red-500 text-center mb-4 h-5"></p>
                <div id="keypad" class="grid grid-cols-3 gap-3">
                    <!-- Keypad buttons will be generated by JS -->
                </div>
            </div>
        </div>

        <!-- Chat Screen (Initially Hidden) -->
        <div id="chat-screen" class="h-full w-full flex flex-col hidden">
            
            <!-- Header -->
            <header class="bg-white border-b border-gray-200 p-3 flex justify-between items-center flex-shrink-0">
                <div class="flex items-center space-x-3">
                    <!-- Back button (for show, logs out) -->
                    <button id="logout-button-back" title="Logout">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                        </svg>
                    </button>
                    <!-- User Display Name -->
                    <h2 id="user-display-name" class="text-lg font-semibold text-gray-900 truncate">
                        Loading...
                    </h2>
                </div>
                
                <!-- Header Buttons -->
                <div class="flex items-center space-x-4">
                    <button id="clear-chat-button" title="Clear Chat for Me">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    </button>
                    <button id="logout-button" title="Logout">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                        </svg>
                    </button>
                </div>
            </header>

            <!-- Chat Messages Area -->
            <!-- 
              KEY LAYOUT FIX: 
              flex-1: Makes it take all available space.
              min-h-0: Allows it to shrink when the keyboard appears.
            -->
            <div id="chat-messages" class="flex-1 min-h-0 p-4 space-y-3 overflow-y-auto" 
                 style="background-image: url('https://placehold.co/100x100/f3f4f6/f3f4f6?text=+'); background-color: #f3f4f6;">
                <!-- Messages will be injected here by JS -->
            </div>

            <!-- "Uploading" Indicator -->
            <div id="uploading-indicator" class="px-4 py-2 text-sm text-gray-500 hidden flex-shrink-0">
                Uploading file...
            </div>

            <!-- Message Input Footer -->
            <!-- 
              KEY LAYOUT FIX: 
              - flex-shrink-0: Prevents this footer from shrinking.
              - removed space-x-2 from form
              - added mx-2 to input field
            -->
            <form id="message-form" class="bg-white border-t border-gray-200 p-3 flex items-center flex-shrink-0">
                <!-- Attachment Button -->
                <button type="button" id="attach-file-button" class="p-2 text-gray-600 hover:text-blue-600 flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.414a4 4 0 00-5.656-5.656l-6.415 6.415a6 6 0 108.486 8.486L20.5 13" />
                    </svg>
                </button>
                <input type="file" id="file-input" class="hidden-file-input">

                <!-- Text Input -->
                <input type="text" id="message-input"
                       class="flex-1 min-w-0 bg-white border border-gray-300 rounded-full py-2 px-4 text-gray-900 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 mx-2"
                       placeholder="Type a message..." autocomplete="off">
                
                <!-- Send Button -->
                <button type="submit" id="send-button" class="p-2 bg-blue-600 text-white rounded-full flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                    </svg>
                </button>
            </form>
        </div>
    </div>

    <!-- Confirmation Modal (Initially Hidden) -->
    <div id="confirmation-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="modal-title" class="text-lg font-semibold text-gray-900 mb-4">Are you sure?</h3>
            <p id="modal-message" class="text-sm text-gray-700 mb-6">This will permanently clear the chat history only for you. The other user will still see all messages.</p>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-button" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">
                    Cancel
                </button>
                <button id="modal-confirm-button" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">
                    Clear
                </button>
            </div>
        </div>
    </div>


    <!-- Firebase App (auto-init) -->
    
    <script type="module">
        import { firebaseConfig } from './config.js';
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            onAuthStateChanged, 
            signInWithCustomToken, 
            signInAnonymously,
            signOut 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            setLogLevel, 
            collection, 
            query, 
            orderBy, 
            onSnapshot, 
            addDoc, 
            serverTimestamp,
            getDocs,
            writeBatch,
            doc,
            setDoc,
            getDoc,
            Timestamp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { 
            getStorage, 
            ref, 
            uploadBytesResumable, 
            getDownloadURL,
            getMetadata
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // --- App Configuration ---

        // User PINs and details
        const FIRST_USER_PINS = {
            "604505": { id: "user1", name: "Logged In User 1 d" },
            "950960": { id: "user2", name: "Logged In User 2 m" }
        };

        const SECOND_USER_PINS = {
            "user1": "193746",
            "user2": "917364"
        };

        // Firebase services
        let db, auth, storage;
        
        // App state
        let currentUserId = null;
        let currentChatUser = null;
        let pinInputs = [];
        let currentPin = "";
        let unsubscribeMessages = null;
        let unsubscribeUserDoc = null;
        let userClearedAtTimestamp = null; // Stores the user's "cleared at" time
        let allMessages = []; // Local cache of all messages
        let isUploading = false;
        
        // Login state
        let loginStep = 1;
        let pendingUser = null;

        // Firestore paths
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-chat-app';
        const chatCollectionPath = `/artifacts/${appId}/public/data/chat-messages`;
        
        // This path is user-specific and requires auth
        const chatUserCollectionPath = (userId) => `/artifacts/${appId}/users/${userId}/chat-settings`;
        const chatUserDocPath = (userId) => `${chatUserCollectionPath(userId)}/${userId}`;


        // --- DOM Elements ---
        const loginScreen = document.getElementById("login-screen");
        const loginTitle = document.getElementById("login-title");
        const chatScreen = document.getElementById("chat-screen");
        const pinInputsContainer = document.getElementById("pin-inputs");
        const loginError = document.getElementById("login-error");
        const keypadContainer = document.getElementById("keypad");
        const userDisplayName = document.getElementById("user-display-name");
        const chatMessages = document.getElementById("chat-messages");
        const messageForm = document.getElementById("message-form");
        const messageInput = document.getElementById("message-input");
        const sendButton = document.getElementById("send-button");
        const attachFileButton = document.getElementById("attach-file-button");
        const fileInput = document.getElementById("file-input");
        const uploadingIndicator = document.getElementById("uploading-indicator");
        const logoutButton = document.getElementById("logout-button");
        const logoutButtonBack = document.getElementById("logout-button-back");
        const clearChatButton = document.getElementById("clear-chat-button");
        const modal = document.getElementById("confirmation-modal");
        const modalTitle = document.getElementById("modal-title");
        const modalMessage = document.getElementById("modal-message");
        const modalCancel = document.getElementById("modal-cancel-button");
        const modalConfirm = document.getElementById("modal-confirm-button");
        let modalConfirmCallback = null;


        // --- Firebase Initialization ---

        function initializeFirebase() {
            try {

                // Change this line
              
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                storage = getStorage(app);
                setLogLevel('Debug'); // Enable Firestore debug logging

                // Start authentication
                authenticateUser();

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                document.body.innerHTML = `<div class="p-4 text-red-500"><strong>Error:</strong> ${error.message}<br>Please check the console and your \`firebaseConfig\` in the script.</div>`;
            }
        }

        // --- Authentication ---

        async function authenticateUser() {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // User is signed in.
                    currentUserId = user.uid;
                    console.log("Firebase user authenticated:", currentUserId);
                } else {
                    // User is signed out.
                    currentUserId = null;
                    console.log("No Firebase user. App may not function correctly.");
                }
            });

            try {
                // Check if the platform's custom token is available
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    console.log("Attempting sign in with custom token...");
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    // Fallback to anonymous sign-in for local development
                    console.log("Attempting sign in anonymously...");
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Auth Error:", error);
                // Handle specific auth errors
                if (error.code === 'auth/configuration-not-found') {
                    showError("Auth Error: Please enable 'Identity Platform' in your Google Cloud project (for project law-dhartee) to fix this.");
                } else if (error.code === 'auth/admin-restricted-operation') {
                    showError("Auth Error: Please enable 'Anonymous' sign-in in your Firebase > Authentication > Sign-in method settings.");
                } else {
                    showError(`Auth Error: ${error.message}`);
                }
            }
        }
        
        function showError(message) {
            // A helper to show errors on the login screen
            if (loginScreen.classList.contains('hidden')) {
                document.body.innerHTML = `<div class="p-4 text-red-500">${message}</div>`;
            } else {
                loginError.textContent = message;
            }
        }


        // --- Login Screen Logic ---

        function setupLoginScreen() {
            // Create PIN inputs
            for (let i = 0; i < 6; i++) {
                const input = document.createElement("input");
                input.type = "password";
                input.maxLength = 1;
                input.readOnly = true;
                input.classList.add("w-10", "h-12", "text-center", "text-2xl", "font-bold", "bg-gray-100", "border", "border-gray-300", "rounded-md", "focus:outline-none", "focus:ring-2", "focus:ring-blue-500", "text-gray-900");
                pinInputsContainer.appendChild(input);
                pinInputs.push(input);
            }

            // Create Keypad
            const keys = [1, 2, 3, 4, 5, 6, 7, 8, 9, "Clear", 0, "Del"];
            keys.forEach(key => {
                const button = document.createElement("button");
                button.textContent = key;
                button.classList.add("py-4", "text-xl", "font-semibold", "rounded-lg", "focus:outline-none", "focus:ring-2", "focus:ring-blue-500");
                if (key === "Clear" || key === "Del") {
                    button.classList.add("bg-gray-200", "text-gray-800");
                } else {
                    button.classList.add("bg-gray-100", "text-gray-900");
                }
                button.addEventListener("click", () => handleKeypadPress(key));
                keypadContainer.appendChild(button);
            });
        }

        function handleKeypadPress(key) {
            loginError.textContent = ""; // Clear error on press

            if (typeof key === "number" && currentPin.length < 6) {
                currentPin += key;
                pinInputs[currentPin.length - 1].value = key;
                
                // Check if PIN is complete
                if (currentPin.length === 6) {
                    handlePinEntry();
                }
            } else if (key === "Del" && currentPin.length > 0) {
                pinInputs[currentPin.length - 1].value = "";
                currentPin = currentPin.slice(0, -1);
            } else if (key === "Clear") {
                resetPinInputs();
            }
        }

        function resetPinInputs() {
            currentPin = "";
            pinInputs.forEach(input => (input.value = ""));
            loginError.textContent = "";
        }

        function handlePinEntry() {
            if (loginStep === 1) {
                // --- Handle First PIN ---
                const user = FIRST_USER_PINS[currentPin];
                if (user) {
                    // Check if user is already logged in
                    if (user.id === currentChatUser) {
                        loginError.textContent = "User already logged in.";
                        setTimeout(resetPinInputs, 1000);
                        return;
                    }
                    
                    // First PIN is correct, move to step 2
                    pendingUser = user;
                    loginStep = 2;
                    loginTitle.textContent = "Enter Your PIN";
                    setTimeout(resetPinInputs, 200); // Clear inputs for second PIN

                } else {
                    loginError.textContent = "Invalid PIN. Please try again.";
                    setTimeout(resetPinInputs, 1000);
                }
            } else if (loginStep === 2) {
                // --- Handle Second PIN ---
                const expectedPin = SECOND_USER_PINS[pendingUser.id];
                
                if (currentPin === expectedPin) {
                    // Second PIN is correct, log in
                    console.log(`Login successful for ${pendingUser.id}`);
                    currentChatUser = pendingUser.id;
                    userDisplayName.textContent = pendingUser.name;
                    
                    // Proceed to chat screen
                    showChatScreen();
                    
                    // Reset login state for next time
                    pendingUser = null;
                    loginStep = 1;
                    loginTitle.textContent = "Enter Your PIN";
                    // resetPinInputs() is called by showChatScreen()

                } else {
                    loginError.textContent = "Invalid Second PIN. Please try again.";
                    setTimeout(resetPinInputs, 1000);
                }
            }
        }

        // --- Chat Screen Logic ---

        async function showChatScreen() {
            if (!currentUserId) {
                showError("Waiting for authentication... Please wait and try logging in again.");
                resetPinInputs();
                // Also reset login flow
                loginStep = 1;
                pendingUser = null;
                loginTitle.textContent = "Enter Your PIN";
                return;
            }
            
            // **NEW CHAT HISTORY FIX (Part 1):**
            // Wait to get the 'clearedAt' time first.
            await listenToUserDoc(currentChatUser); 
            
            // Now that we have the 'clearedAt' time, load the messages.
            loadChatMessages();
            
            loginScreen.classList.add("hidden");
            chatScreen.classList.remove("hidden");
            resetPinInputs();
        }

        function showLoginScreen() {
            if (unsubscribeMessages) {
                unsubscribeMessages(); // Stop listening to messages
                unsubscribeMessages = null;
            }
            if (unsubscribeUserDoc) {
                unsubscribeUserDoc(); // Stop listening to user doc
                unsubscribeUserDoc = null;
            }
            
            currentChatUser = null;
            userClearedAtTimestamp = null;
            allMessages = []; // Clear local message cache
            chatMessages.innerHTML = ""; // Clear UI

            chatScreen.classList.add("hidden");
            loginScreen.classList.remove("hidden");
            
            // Reset login flow state
            loginStep = 1;
            pendingUser = null;
            loginTitle.textContent = "Enter Your PIN";
            resetPinInputs();

            console.log("User logged out.");
        }

        // --- "Clear for Me" Logic ---

        // **NEW CHAT HISTORY FIX (Part 2):**
        // This function now just fetches the 'clearedAt' timestamp
        // and resolves a promise when done.
        function listenToUserDoc(userId) {
             return new Promise((resolve, reject) => {
                if (unsubscribeUserDoc) {
                    unsubscribeUserDoc();
                }
                
                const userDocRef = doc(db, chatUserDocPath(currentUserId));
                
                unsubscribeUserDoc = onSnapshot(userDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        userClearedAtTimestamp = data.clearedAt || null;
                        console.log(`'clearedAt' timestamp for ${userId}:`, userClearedAtTimestamp);
                    } else {
                        userClearedAtTimestamp = null;
                        console.log(`No 'clearedAt' doc found for ${userId}, setting to null.`);
                    }
                    // Resolve the promise once we have the timestamp
                    resolve(); 
                }, (error) => {
                    console.error(`Error listening to user doc ${userId}:`, error);
                    // Don't reject, just resolve. App can continue with null timestamp.
                    userClearedAtTimestamp = null;
                    resolve(); 
                });
            });
        }

        async function clearMyChatMessages() {
            if (!currentUserId) {
                console.error("Cannot clear chat, no auth user ID.");
                return;
            }

            const userDocRef = doc(db, chatUserDocPath(currentUserId));
            
            try {
                // Set (or overwrite) the clearedAt field with the current server time
                await setDoc(userDocRef, { 
                    clearedAt: serverTimestamp() 
                }, { merge: true }); // Use merge to avoid overwriting other fields
                
                console.log(`Chat 'clearedAt' timestamp set for user ${currentChatUser}`);
                
                // No need to manually clear UI, the onSnapshot listener
                // in listenToUserDoc will see the change and trigger
                // filterAndDisplayMessages to re-render.
                
            } catch (error) {
                console.error("Error setting 'clearedAt' timestamp: ", error);
            }
        }


        // --- Message Handling ---

        function loadChatMessages() {
            if (unsubscribeMessages) {
                unsubscribeMessages();
            }

            const q = query(collection(db, chatCollectionPath));
            
            unsubscribeMessages = onSnapshot(q, (querySnapshot) => {
                allMessages = []; // Reset local cache
                querySnapshot.forEach((doc) => {
                    allMessages.push({ id: doc.id, ...doc.data() });
                });
                
                // Sort messages by timestamp (client-side)
                // This is more reliable than Firestore's orderBy if we're filtering
                allMessages.sort((a, b) => {
                    const tsA = a.timestamp?.toMillis() || 0;
                    const tsB = b.timestamp?.toMillis() || 0;
                    return tsA - tsB;
                });

                console.log(`Loaded ${allMessages.length} total messages.`);
                filterAndDisplayMessages();

            }, (error) => {
                console.error("Error loading chat messages: ", error);
            });
        }
        
        // **NEW CHAT HISTORY FIX (Part 3):**
        // This function now filters the `allMessages` cache
        // based on the `userClearedAtTimestamp`.
        function filterAndDisplayMessages() {
            chatMessages.innerHTML = ""; // Clear existing messages
            
            let messagesToDisplay = allMessages;

            // Apply the "clearedAt" filter
            if (userClearedAtTimestamp) {
                messagesToDisplay = allMessages.filter(msg => {
                    if (!msg.timestamp) return true; // Always show messages without a timestamp? (or false?)
                    return msg.timestamp.toMillis() > userClearedAtTimestamp.toMillis();
                });
                console.log(`Filtering: ${allMessages.length} total -> ${messagesToDisplay.length} to display.`);
            }

            if (messagesToDisplay.length === 0) {
                chatMessages.innerHTML = `<p class="text-center text-gray-500 text-sm">No messages yet.</p>`;
            } else {
                messagesToDisplay.forEach(msg => {
                    displayMessage(msg);
                });
            }
            
            scrollToBottom();
        }


        function displayMessage(msg) {
            const isSent = msg.senderId === currentChatUser;
            const msgTime = msg.timestamp ? new Date(msg.timestamp.toMillis()).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) : "";
            const msgSenderName = FIRST_USER_PINS[msg.senderPin]?.name || "Unknown User";

            const messageWrapper = document.createElement("div");
            messageWrapper.classList.add("flex", isSent ? "justify-end" : "justify-start");
            
            let bubbleContent = '';
            
            if (msg.type === 'file' && msg.fileUrl) {
                // Check if it's an image
                if (msg.mimeType && msg.mimeType.startsWith('image/')) {
                    bubbleContent = `
                        <div class="relative">
                            <img src="${msg.fileUrl}" alt="Uploaded image" class="rounded-lg max-w-full w-full object-cover" style="max-height: 300px;">
                            <span class="image-timestamp">${msgTime}</span>
                        </div>
                    `;
                } else {
                    // It's a generic file link
                    const fileName = msg.content || "Download File";
                    bubbleContent = `
                        <div>
                            <p class="font-semibold text-blue-600 underline">
                                <a href="${msg.fileUrl}" target="_blank" rel="noopener noreferrer">${fileName}</a>
                            </p>
                            <div class="text-right timestamp">${msgTime}</div>
                        </div>
                    `;
                }
            } else if (msg.content) {
                // It's a text message
                bubbleContent = `
                    <div>
                        <p>${msg.content}</p>
                        <div class="text-right timestamp">${msgTime}</div>
                    </div>
                `;
            }

            messageWrapper.innerHTML = `
                <div class="chat-bubble ${isSent ? 'bubble-sent' : 'bubble-received'}">
                    ${!isSent ? `<p class="text-xs font-bold text-blue-600 mb-1">${msgSenderName}</p>` : ''}
                    ${bubbleContent}
                </div>
            `;
            chatMessages.appendChild(messageWrapper);
        }

        async function handleSendMessage(e) {
            e.preventDefault();
            const text = messageInput.value.trim();
            const file = fileInput.files[0];

            if (isUploading) {
                console.log("Already uploading, please wait.");
                return;
            }

            if (!text && !file) {
                return; // Nothing to send
            }

            // Temporarily disable form
            setFormDisabled(true);

            try {
                if (file) {
                    await uploadFile(file);
                    // uploadFile will call sendMessage
                } else if (text) {
                    // Send text message
                    await sendMessage(text, 'text');
                }
            } catch (error) {
                console.error("Error sending message: ", error);
            } finally {
                // Clear inputs and re-enable form
                resetForm();
                setFormDisabled(false);
            }
        }

        async function uploadFile(file) {
            if (!currentUserId) {
                console.error("Cannot upload file, no auth user ID.");
                resetForm();
                setFormDisabled(false);
                return;
            }
            
            isUploading = true;
            uploadingIndicator.classList.remove("hidden");

            try {
                // 1. Get file metadata (MIME type)
                const metadata = {
                    contentType: file.type || 'application/octet-stream',
                    customMetadata: {
                        'originalName': file.name
                    }
                };

                // 2. Create a storage reference
                const storagePath = `chat_files/${currentUserId}/${Date.now()}_${file.name}`;
                const fileRef = ref(storage, storagePath);
                
                // 3. Start the upload
                const uploadTask = uploadBytesResumable(fileRef, file, metadata);

                // 4. Wait for upload to complete
                await uploadTask;
                
                // 5. Get download URL
                const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                
                // 6. Send the message
                await sendMessage(file.name, 'file', downloadURL, metadata.contentType);
                
                console.log("File uploaded and message sent.");
                
            } catch (error) {
                console.error("File upload failed: ", error);
            } finally {
                isUploading = false;
                uploadingIndicator.classList.add("hidden");
                resetForm();
                setFormDisabled(false);
            }
        }

        async function sendMessage(content, type, fileUrl = null, mimeType = null) {
            const senderPin = Object.keys(FIRST_USER_PINS).find(key => FIRST_USER_PINS[key].id === currentChatUser);

            if (!senderPin) {
                console.error("Could not find sender PIN for current user.");
                return;
            }

            try {
                await addDoc(collection(db, chatCollectionPath), {
                    senderId: currentChatUser,
                    senderPin: senderPin, // Store the PIN for display name lookup
                    content: content,
                    timestamp: serverTimestamp(),
                    type: type,
                    fileUrl: fileUrl,
                    mimeType: mimeType
                });
                console.log("Message saved to Firestore.");
            } catch (error) {
                console.error("Error writing message to Firestore: ", error);
            }
        }

        function setFormDisabled(disabled) {
            messageInput.disabled = disabled;
            sendButton.disabled = disabled;
            attachFileButton.disabled = disabled;
        }

        function resetForm() {
            messageInput.value = "";
            fileInput.value = null; // Clear file input
        }

        function scrollToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }


        // --- Event Listeners ---

        function setupEventListeners() {
            // Login
            document.addEventListener("keydown", (e) => {
                if (!loginScreen.classList.contains("hidden")) {
                    if (e.key >= '0' && e.key <= '9') {
                        handleKeypadPress(parseInt(e.key));
                    } else if (e.key === "Backspace") {
                        handleKeypadPress("Del");
                    }
                }
            });

            // Chat
            messageForm.addEventListener("submit", handleSendMessage);
            
            attachFileButton.addEventListener("click", () => {
                fileInput.click(); // Trigger hidden file input
            });

            fileInput.addEventListener("change", () => {
                const file = fileInput.files[0];
                if (file) {
                    // Show file name in the input box as a preview
                    messageInput.value = `File: ${file.name}`;
                    messageInput.focus();
                }
            });

            // Logout
            logoutButton.addEventListener("click", showLoginScreen);
            logoutButtonBack.addEventListener("click", showLoginScreen);
            
            // Immediate logout on back/refresh/disconnect
            window.addEventListener("beforeunload", (e) => {
                // This will trigger a "are you sure?" prompt
                // but we can also use it to log out.
                // Note: a real logout might not complete, but
                // it's good practice.
                if (currentChatUser) {
                    console.log("Unloading page, logging out.");
                    // We can't use async here, so just clear state
                    currentChatUser = null;
                }
            });
            
            window.addEventListener("offline", () => {
                if (currentChatUser) {
                    showError("Internet disconnected. Logging out.");
                    setTimeout(showLoginScreen, 2000);
                }
            });

            // Clear Chat Modal
            clearChatButton.addEventListener("click", () => {
                modalTitle.textContent = "Clear Chat";
                modalMessage.textContent = "This will permanently clear the chat history only for you. The other user will still see all messages.";
                modalConfirmCallback = clearMyChatMessages;
                modal.classList.remove("hidden");
            });

            modalCancel.addEventListener("click", () => {
                modal.classList.add("hidden");
                modalConfirmCallback = null;
            });

            modalConfirm.addEventListener("click", () => {
                if (modalConfirmCallback) {
                    modalConfirmCallback();
                }
                modal.classList.add("hidden");
                modalConfirmCallback = null;
            });
        }


        // --- App Start ---
        document.addEventListener("DOMContentLoaded", () => {
            setupLoginScreen();
            setupEventListeners();
            initializeFirebase();
        });

    </script>
</body>
</html>





